<div class="wikidoc">
<h3>16.&nbsp;Can you read complex pointer declaration?</h3>
<p>&nbsp;Assign the priority to the pointer declaration considering precedence and associative according to following table.</p>
<p><img src="http://download-codeplex.sec.s-msft.com/Download?ProjectName=turboc&DownloadId=1524103" alt="" width="556" height="237"></p>
<p><strong>():</strong> This operator behaves as bracket operator or function operator.</p>
<p><strong>[]:</strong> This operator behaves as array subscription operator.</p>
<p><strong>*:</strong> This operator behaves as pointer operator not as multiplication operator.</p>
<p><strong>Identifier:</strong> It is not an operator but it is name of pointer variable. You will always find the first priority will be assigned to the name of pointer.</p>
<p><strong>Data type:</strong> It is also not an operator. Data types also includes modifier (like signed int, long double etc.)</p>
<p>&nbsp;</p>
<h3>17.&nbsp;What are the parameter passing conventions in c?</h3>
<p><strong>Explanation:</strong><br>
<strong>1. pascal:</strong> In this style function name should (not necessary ) in the uppercase .First parameter of function call is passed to the first parameter of function definition and so on.</p>
<p><strong>2. cdecl:</strong> In this style function name can be both in the upper case or lower case. First parameter of function call is passed to the last parameter of function definition. It is default parameter passing convention.<br>
Examples:</p>
<p>1. What will be output of following program?</p>
<pre><code>int main(){</code><br><code>static int a=25;</code><br><code>void cdecl conv1() ;</code><br><code>void pascal conv2();</code><br><code>conv1(a);</code><br><code>conv2(a);</code><br><code>return 0;;</code><br><code>}</code><br><code>void cdecl conv1(int a,int b)</code><br><code>{</code><br><code>printf(&quot;%d %d&quot;,a,b);</code><br><code>}</code><br><code>void pascal conv2(int a,int b)</code><br><code>{</code><br><code>printf(&quot;\n%d %d&quot;,a,b);</code><br><code>}</code></pre>
<pre><code>Output: 25 0</code><br><code>0 25</code></pre>
<p>(2) What will be output of following program?</p>
<pre><code>void cdecl fun1(int,int);</code><br><code>void pascal fun2(int,int);</code><br><code>int main(){</code><br><code> int a=5,b=5;</code><br> <br><code> fun1(a,&#43;&#43;a);</code><br><code> fun2(b,&#43;&#43;b);</code><br><code> return 0;</code><br><code>}</code><br><code>void cdecl fun1(int p,int q){</code><br><code> printf(&quot;cdecl: %d %d \n&quot;,p,q);</code><br><code>}</code><br><code>void pascal fun2(int p,int q){</code><br><code> printf(&quot;pascal: %d %d&quot;,p,q);</code><br><code>}</code></pre>
<pre><code>Output:</code><br><code>cdecl: 6 6</code><br><code>pascal: 5 6</code></pre>
<p>(3) What will be output of following program?</p>
<pre><code>void cdecl fun1(int,int);</code><br><code>void pascal fun2(int,int);</code><br><code>int main(){</code><br><code> int a=5,b=5;</code><br> <br><code> fun1(a,&#43;&#43;a);</code><br><code> fun2(b,&#43;&#43;b);</code><br><code> return 0;</code><br><code>}</code><br><code>void cdecl fun1(int p,int q){</code><br><code> printf(&quot;cdecl: %d %d \n&quot;,p,q);</code><br><code>}</code><br><code>void pascal fun2(int p,int q){</code><br><code> printf(&quot;pascal: %d %d&quot;,p,q);</code><br><code>}</code></pre>
<pre><code>Output:</code><br><code>cdecl: 6 6</code><br><code>pascal: 5 6</code></pre>
<p>(4) What will be output of following program?</p>
<pre><code>void convention(int,int,int);</code><br><code>int main(){</code><br><code> int a=5;</code><br> <br><code> convention(a,&#43;&#43;a,a&#43;&#43;);</code><br><code> return 0;</code><br><code>}</code><br><code>void convention(int p,int q,int r){</code><br><code> printf(&quot;%d %d %d&quot;,p,q,r);</code><br><code>}</code></pre>
<pre><code>Output: 7 7 5</code><br>(5) What will be output of following program?</pre>
<pre><code>void pascal convention(int,int,int);</code><br><code>int main(){</code><br><code> int a=5;</code><br> <br><code> convention(a,&#43;&#43;a,a&#43;&#43;);</code><br><code> return 0;}</code><br><code>void pascal convention(int p,int q,int r){</code><br><code> printf(&quot;%d %d %d&quot;,p,q,r);</code><br><code>}</code></pre>
<p>Output: 5 6 6</p>
<p>(6) What will be output of following program?</p>
<pre><code>void pascal convention(int,int);</code><br><code>int main(){</code><br><code> int a=1;</code><br> <br><code> convention(a,&#43;&#43;a);</code><br><code> return 0;</code><br><code>}</code><br><code>void pascal convention(int a,int b){</code><br><code> printf(&quot;%d %d&quot;,a,b);</code><br><code>}</code></pre>
<p>Output: 1 2</p>
<p>(7) What will be output of following program?</p>
<pre><code>void convention(int,int);</code><br><code>int main(){</code><br><code> int a=1;</code><br> <br><code> convention(a,&#43;&#43;a);</code><br><code> return 0;}</code><br><code>void convention(int a,int b){</code><br><code> printf(&quot;%d %d&quot;,a,b);</code><br><code>}</code></pre>
<p>Output: 2 2</p>
<h3>18.&nbsp;What is the far pointer in c?&nbsp;</h3>
<p>The pointer which can point or access whole the residence memory of RAM i.e. which can access all 16 segments is known as far pointer.</p>
<p><img src="http://download-codeplex.sec.s-msft.com/Download?ProjectName=turboc&DownloadId=1524105" alt="" width="316" height="400"></p>
<p>Size of far pointer is 4 byte or 32 bit. Examples:</p>
<p>(1) What will be output of following c program?</p>
<pre><code>int main(){</code><br><code>int x=10;</code><br><code>int far *ptr;</code><br><code>ptr=&amp;x;</code><br><code>printf(&quot;%d&quot;,sizeof ptr);</code><br><code>return 0;</code><br><code>}<br></code>Output: 4</pre>
<p>(2)What will be output of following c program?</p>
<pre><code>int main(){</code><br><code>int far *near*ptr;</code><br><code>printf(&quot;%d %d&quot;,sizeof(ptr) ,sizeof(*ptr));</code><br><code>return 0;</code><br><code>}<br>Output: 4 2</code></pre>
<p><strong>Explanation:</strong> ptr is far pointer while *ptr is near pointer.</p>
<p>(3)What will be output of following c program?</p>
<pre><code>int main(){</code><br><code>int far *p,far *q;</code><br><code>printf(&quot;%d %d&quot;,sizeof(p) ,sizeof(q));</code><br><code>}<br>Output: 4 4</code></pre>
<p>First 16 bit stores: Segment number<br>
Next 16 bit stores: Offset address</p>
<p>Example:</p>
<pre><code>int main(){</code><br><code>int x=100;</code><br><code>int far *ptr;</code><br><code>ptr=&amp;x;</code><br><code>printf(&quot;%Fp&quot;,ptr);</code><br><code>return 0;</code><br><code>}<br></code>Output: 8FD8:FFF4</pre>
<pre>Here 8FD8 is segment address and FFF4 is offset address in hexadecimal number format.</pre>
<p>Note: %Fp is used for print offset and segment address of pointer in printf function in hexadecimal number format.<br>
In the header file dos.h there are three macro functions to get the offset address and segment address from far pointer and vice versa.</p>
<p>1. FP_OFF(): To get offset address from far address.<br>
2. FP_SEG(): To get segment address from far address.<br>
3. MK_FP(): To make far address from segment and offset address.</p>
<p>Examples:<br>
(1)What will be output of following c program?</p>
<pre><code>#include &quot;dos.h&quot;</code><br><code>int main(){</code><br><code>int i=25;</code><br><code>int far*ptr=&amp;i;</code><br><code>printf(&quot;%X %X&quot;,FP_SEG(ptr),FP_OFF(ptr));</code><br><code>}<br></code>Output: Any segment and offset address in hexadecimal number format respectively.</pre>
<p>(2)What will be output of following c program?</p>
<pre><code>#include &quot;dos.h&quot;</code><br><code>int main(){</code><br><code>int i=25;</code><br><code>int far*ptr=&amp;i;</code><br><code>unsigned int s,o;</code><br><code>s=FP_SEG(ptr);</code><br><code>o=FP_OFF(ptr);</code><br><code>printf(&quot;%Fp&quot;,MK_FP(s,o));</code><br><code>return 0;</code><br><code>}<br></code>Output: 8FD9:FFF4 (Assume)</pre>
<pre>Note: We cannot guess what will be offset address; segment address and far address of any far pointer .These address are decided by operating system.</pre>
<p>Limitation of far pointer:</p>
<p>We cannot change or modify the segment address of given far address by applying any arithmetic operation on it. That is by using arithmetic operator we cannot jump from one segment to other segment. If you will increment the far address beyond the maximum
 value of its offset address instead of incrementing segment address it will repeat its offset address in cyclic order.</p>
<p>Example:</p>
<p>(q)What will be output of following c program?</p>
<pre><code>int main(){</code><br><code>int i;</code><br><code>char far *ptr=(char *)0xB800FFFA;</code><br><code>for(i=0;i&lt;=10;i&#43;&#43;){</code><br><code>printf(&quot;%Fp \n&quot;,ptr);</code><br><code>ptr&#43;&#43;;</code><br><code>}</code><br><code>return 0;</code><br><code>}<br></code>Output:<br>B800:FFFA<br>B800:FFFB<br>B800:FFFC<br>B800:FFFD<br>B800:FFFE<br>B800:FFFF<br>B800:0000<br>B800:0001<br>B800:0002<br>B800:0003<br>B800:0004</pre>
<p>This property of far pointer is called cyclic nature of far pointer within same segment.</p>
<p>Important points about far pointer:</p>
<p>1. Far pointer compares both offset address and segment address with relational operators.</p>
<p>Examples:</p>
<p>(1)What will be output of following c program?</p>
<pre><code>int main(){</code><br><code>int far *p=(int *)0X70230000;</code><br><code>int far *q=(int *)0XB0210000;</code><br><code>if(p==q)</code><br><code>printf(&quot;Both pointers are equal&quot;);</code><br><code>else</code><br><code>printf(&quot;Both pointers are not equal&quot;);</code><br><code>return 0;</code><br><code>}<br></code>Output: Both pointers are not equal</pre>
<p>(2)What will be output of following c program?</p>
<pre><code>int main(){</code><br><code>int far *p=(int *)0X70230000;</code><br><code>int far *q=(int *)0XB0210000;</code><br><code>int near *x,near*y;</code><br><code>x=(int near *)p;</code><br><code>y=(int near *)q;</code><br><code>if(x==y)</code><br><code>printf(&quot;Both pointer are equal&quot;);</code><br><code>else</code><br><code>printf(&quot;Both pointer are not equal&quot;);</code><br><code>return 0;</code><br><code>}<br></code>Output: Both pointers are equal</pre>
<p>2. Far pointer doesn&rsquo;t normalize.</p>
<h3>19.&nbsp;What is a cyclic property of data type in c? Explain with any example.</h3>
<pre><code>#include&lt;stdio.h&gt;</code><br><code>int main(){</code><br><code> signed char c1=130;</code><br><code> signed char c2=-130;</code><br><code> printf(&quot;%d %d&quot;,c1,c2);</code><br><code> return 0;</code><br><code>}</code></pre>
<pre><code>Output: -126 126 (why?)</code></pre>
<p><br>
This situation is known as overflow of signed char. <br>
Range of unsigned char is -128 to 127. If we will assign a value greater than 127 then value of variable will be changed to a value if we will move clockwise direction as shown in the figure according to number. If we will assign a number which is less than
 -128 then we have to move in anti-clockwise direction.</p>
<p><img src="http://download-codeplex.sec.s-msft.com/Download?ProjectName=turboc&DownloadId=1524104" alt="" width="297" height="320"></p>
<p>&nbsp;</p>
<h3>20.&nbsp;What is&nbsp;difference&nbsp;between&nbsp;uninitialized&nbsp;pointer and null pointer?&nbsp;&nbsp;</h3>
<p><strong>Explanation:</strong><br>
An uninitialized pointer is a pointer which points unknown memory location while null pointer is pointer which points a null value or base address of segment. For example:</p>
<pre><code>int *p; //Uninitialized pointer</code><br><code>int *q= (int *)0; //Null pointer</code><br><code>#include&lt;stdio.h&gt;</code><br><code>int *r=NULL; //Null pointer</code></pre>
<p>What will be output of following c program?</p>
<pre><code>#include&lt;string.h&gt;</code><br><code>#include&lt;stdio.h&gt;</code><br><code>int main(){</code><br><code> char *p; //Uninitialized pointer</code><br><code> char *q=NULL; //Null pointer;</code><br><code> strcpy(p,&quot;turboc.codeplex.com&quot;);</code><br><code> strcpy(q,&quot;turboc.codeplex.com&quot;);</code><br><code>printf(&quot;%s %s&quot;,p,q);</code><br><code> return 0;</code><br><code>}</code></pre>
<pre><code>Output: turboc.codeplex.com (null)</code></pre>
<h2><a href="https://turboc.codeplex.com/wikipage?title=C%20Programming%20Interview%20Question%20Part%203">&lt;&lt;C Programming Interview Question Part 3</a></h2>
</div><div class="ClearBoth"></div>