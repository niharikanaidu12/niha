<div class="wikidoc">
<h2><strong>Structures</strong></h2>
<p>Before discussing classes, this lesson will be an introduction to data structures similar to classes. Structures are a way of storing many different values in variables of potentially different types under the same name. This makes it a more modular program,
 which is easier to modify because its design makes things more compact. Structs are generally useful whenever a lot of data needs to be grouped together--for instance, they can be used to hold records from a database or to store information about contacts
 in an address book. In the contacts example, a struct could be used that would hold all of the information about a single contact--name, address, phone number, and so forth.&nbsp;</p>
<p><br>
The format for defining a structure is</p>
<pre>struct Tag {
  Members
};
</pre>
<p>Where Tag is the name of the entire type of structure and Members are the variables within the struct. To actually create a single structure the syntax is</p>
<pre>struct Tag name_of_single_structure;
</pre>
<p>To access a variable of the structure it goes</p>
<pre>name_of_single_structure.name_of_variable;
</pre>
<p>For example:</p>
<pre>struct example {
  int x;
};
struct example an_example; //Treating it like a normal variable type
an_example.x = 33;  //How to access its members
</pre>
<p>Here is an example program:</p>
<pre>struct database {
  int id_number;
  int age;
  float salary;
};

int main()
{
  database employee;  //There is now an employee variable that has modifiable 
                      // variables inside it.
  employee.age = 22;
  employee.id_number = 1;
  employee.salary = 12000.21;
}
</pre>
<p>The struct database declares that database has three variables in it, age, id_number, and salary. You can use database like a variable type like int. You can create an employee with the database type as I did above. Then, to modify it you call everything
 with the 'employee.' in front of it. You can also return structures from functions by defining their return type as a structure type. For instance:</p>
<pre>database fn();
</pre>
<p>I will talk only a little bit about unions as well. Unions are like structures except that all the variables share the same memory. When a union is declared the compiler allocates enough memory for the largest data-type in the union. It's like a giant storage
 chest where you can store one large item, or a small item, but never the both at the same time.&nbsp;<br>
<br>
The '.' operator is used to access different variables inside a union also.&nbsp;<br>
<br>
As a final note, if you wish to have a pointer to a structure, to actually access the information stored inside the structure that is pointed to, you use the -&gt; operator in place of the . operator. All points about pointers still apply.&nbsp;<br>
<br>
A quick example:</p>
<pre>#include &lt;iostream&gt;

using namespace std;

struct xampl {
  int x;
};

int main()
{  
  xampl structure;
  xampl *ptr;
  
  structure.x = 12;
  ptr = &amp;structure; // Yes, you need the &amp; when dealing with structures
                    //  and using pointers to them
  cout&lt;&lt; ptr-&gt;x;    // The -&gt; acts somewhat like the * when used with pointers
                    //  It says, get whatever is at that memory address
                    //  Not &quot;get what that memory address is&quot;
  cin.get();                    
}<br><br><strong>&quot;Tutorial from&nbsp;<a href="http://www.cprogramming.com/" target="_blank">http://www.cprogramming.com</a>&nbsp;by Alexander Allain. Cprogramming.com serves programming audiences with tutorials and articles on programming, along with free source code and an active message board.&quot;&nbsp;</strong></pre>
</div><div class="ClearBoth"></div>